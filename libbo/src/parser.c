//  Copyright (c) 2018 Karl Stenerud. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall remain in place
// in this source code.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//


#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include "bo_internal.h"


// --------------
// Generated Code
// --------------

// Generated by build_types_table.c
typedef enum
{
    CHARACTER_FLAG_NONE = 0x00,
    CHARACTER_FLAG_CONTROL = 0x01,
    CHARACTER_FLAG_WHITESPACE = 0x02,
    CHARACTER_FLAG_BASE_10 = 0x04,
    CHARACTER_FLAG_BASE_16 = 0x08,
    CHARACTER_FLAG_NUMBER = 0x10,
    CHARACTER_FLAG_ALPHANUMERIC = 0x20,
    CHARACTER_FLAG_SYMBOL = 0x40,
    CHARACTER_FLAG_PRINTABLE = 0x80,
} character_flag;

// Generated by build_types_table.c
static const uint8_t g_character_flags[256] =
{
    /* NUL   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* SOH   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* STX   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* ETX   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* EOT   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* ENQ   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* ACK   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* BEL   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* BS    */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* HT    */ (uint8_t)(CHARACTER_FLAG_CONTROL | CHARACTER_FLAG_WHITESPACE),
    /* LF    */ (uint8_t)(CHARACTER_FLAG_CONTROL | CHARACTER_FLAG_WHITESPACE),
    /* VT    */ (uint8_t)(CHARACTER_FLAG_CONTROL | CHARACTER_FLAG_WHITESPACE),
    /* FF    */ (uint8_t)(CHARACTER_FLAG_CONTROL | CHARACTER_FLAG_WHITESPACE),
    /* CR    */ (uint8_t)(CHARACTER_FLAG_CONTROL | CHARACTER_FLAG_WHITESPACE),
    /* SO    */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* SI    */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* DLE   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* DC1   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* DC2   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* DC3   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* DC4   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* NAK   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* SYN   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* ETB   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* CAN   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* EM    */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* SUB   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* ESC   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* FS    */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* GS    */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* RS    */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* US    */ (uint8_t)(CHARACTER_FLAG_CONTROL),
    /* Space */ (uint8_t)(CHARACTER_FLAG_WHITESPACE),
    /* !     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* "     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* #     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* $     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* %     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* &     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* '     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* (     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* )     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* *     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* +     */ (uint8_t)(CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* ,     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* -     */ (uint8_t)(CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* .     */ (uint8_t)(CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* /     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* 0     */ (uint8_t)(CHARACTER_FLAG_BASE_10 | CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* 1     */ (uint8_t)(CHARACTER_FLAG_BASE_10 | CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* 2     */ (uint8_t)(CHARACTER_FLAG_BASE_10 | CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* 3     */ (uint8_t)(CHARACTER_FLAG_BASE_10 | CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* 4     */ (uint8_t)(CHARACTER_FLAG_BASE_10 | CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* 5     */ (uint8_t)(CHARACTER_FLAG_BASE_10 | CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* 6     */ (uint8_t)(CHARACTER_FLAG_BASE_10 | CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* 7     */ (uint8_t)(CHARACTER_FLAG_BASE_10 | CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* 8     */ (uint8_t)(CHARACTER_FLAG_BASE_10 | CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* 9     */ (uint8_t)(CHARACTER_FLAG_BASE_10 | CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* :     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* ;     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* <     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* =     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* >     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* ?     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* @     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* A     */ (uint8_t)(CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* B     */ (uint8_t)(CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* C     */ (uint8_t)(CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* D     */ (uint8_t)(CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* E     */ (uint8_t)(CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* F     */ (uint8_t)(CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* G     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* H     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* I     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* J     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* K     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* L     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* M     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* N     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* O     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* P     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* Q     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* R     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* S     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* T     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* U     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* V     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* W     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* X     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* Y     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* Z     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* [     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* \     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* ]     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* ^     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* _     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* `     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* a     */ (uint8_t)(CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* b     */ (uint8_t)(CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* c     */ (uint8_t)(CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* d     */ (uint8_t)(CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* e     */ (uint8_t)(CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* f     */ (uint8_t)(CHARACTER_FLAG_BASE_16 | CHARACTER_FLAG_NUMBER | CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* g     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* h     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* i     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* j     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* k     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* l     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* m     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* n     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* o     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* p     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* q     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* r     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* s     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* t     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* u     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* v     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* w     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* x     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* y     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* z     */ (uint8_t)(CHARACTER_FLAG_ALPHANUMERIC | CHARACTER_FLAG_PRINTABLE),
    /* {     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* |     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* }     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* ~     */ (uint8_t)(CHARACTER_FLAG_SYMBOL | CHARACTER_FLAG_PRINTABLE),
    /* DEL   */ (uint8_t)(CHARACTER_FLAG_CONTROL),
};



// -------
// Utility
// -------

static inline bool is_decimal_character(int ch)
{
    return g_character_flags[ch] & CHARACTER_FLAG_BASE_10;
}

static inline bool is_hex_character(int ch)
{
    return g_character_flags[ch] & CHARACTER_FLAG_BASE_16;
}

static inline bool is_numeric_character(int ch)
{
    return g_character_flags[ch] & CHARACTER_FLAG_NUMBER;
}

static inline bool is_whitespace_character(int ch)
{
    return g_character_flags[ch] & CHARACTER_FLAG_WHITESPACE;
}

static inline bool is_at_end_of_input(bo_context* context)
{
    return context->is_at_end_of_input;
}

static inline bool is_last_data_segment(bo_context* context)
{
    return context->is_last_data_segment;
}

static inline void set_parse_interrupted_at(bo_context* context, char* position)
{
    context->parse_position = position;
    context->parse_should_continue = false;
}

static bo_data_type extract_data_type(bo_context* context, char* token, int offset)
{
    bo_data_type data_type = token[offset];
    switch(data_type)
    {
        case TYPE_BINARY:
        case TYPE_INT:
        case TYPE_HEX:
        case TYPE_OCTAL:
        case TYPE_BOOLEAN:
        case TYPE_FLOAT:
        case TYPE_DECIMAL:
        case TYPE_STRING:
            return data_type;
        case 0:
            bo_notify_error(context, "%s: offset %d: Missing data type", token, offset);
            return TYPE_NONE;
        default:
            bo_notify_error(context, "%s: offset %d: %c is not a valid data type", token, offset, (char)data_type);
            return TYPE_NONE;
    }
}

static int extract_data_width(bo_context* context, char* token, int offset)
{
    switch(token[offset])
    {
        case '1':
            switch(token[offset + 1])
            {
                case '6':
                    return 16;
                case '0': case '1': case '2': case '3': case '4': case '5':
                case '7': case '8': case '9':
                {
                    unsigned int width = strtoul(token + offset, NULL, 16);
                    bo_notify_error(context, "%s: offset %d: %d is not a valid data width", token, offset, width);
                    return 0;
                }
                default:
                    return 1;
            }
        case '2':
            return 2;
        case '4':
            return 4;
        case '8':
            return 8;
        case '0': case '3': case '5': case '6': case '7': case '9':
        {
            unsigned int width = strtoul(token + offset, NULL, 10);
            bo_notify_error(context, "%s: offset %d: %d is not a valid data width", token, offset, width);
            return 0;
        }
        case 0:
            bo_notify_error(context, "%s: offset %d: Missing data width", token, offset);
            return 0;
        default:
            bo_notify_error(context, "%s: offset %d: Not a valid data width", token, offset);
            return 0;
    }
}

static bo_endianness extract_endianness(bo_context* context, char* token, int offset)
{
    char ch = token[offset];
    switch(ch)
    {
        case BO_ENDIAN_LITTLE:
        case BO_ENDIAN_BIG:
            return ch;
        default:
            bo_notify_error(context, "%s: offset %d: %c is not a valid endianness", token, offset, ch);
            return BO_ENDIAN_NONE;
    }
}



// ---------------
// General Parsing
// ---------------

/**
 * Terminate a token.
 * THIS FUNCTION MODIFIES MEMORY!
 *
 * Reads until the first whitespace and replaces the whitespace with null termination.
 * If no whitespace is encountered, marks "end of input" in the context.
 * Regardless of outcome (end of input or not), the current token will have null termination.
 *
 * @param context The context.
 * @param ptr Pointer to the current location in the input text.
 * @return pointer to the end of the token (the null termination).
 */
static void terminate_token(bo_context* context)
{
    char* ptr = context->parse_position;
    for(; *ptr != 0; ptr++)
    {
        if(is_whitespace_character(*ptr))
        {
            *ptr = 0;
            context->parse_position = ptr;
            return;
        }
    }
    context->is_at_end_of_input = true;
    context->parse_position = ptr;
}

/**
 * Parse a string. The input string must begin and end with double quotes (").
 * THIS FUNCTION MODIFIES MEMORY!
 *
 * The string may contain escape sequences, which will be converted to the values they represent.
 * Upon successful completion, the memory at pointer string will contain an unescaped, unquoted,
 * null terminated string.
 *
 * @param context The context.
 * @param string The string to parse.
 * @return A pointer to the beginning of the string, or NULL if an exception occurred.
 */
static char* parse_string(bo_context* context)
{
    char* string = context->parse_position;
    char* write_pos = string;
    char* read_pos = string;
    for(; *read_pos != '"'; read_pos++)
    {
        if(*read_pos == 0)
        {
            if(is_last_data_segment(context))
            {
                bo_notify_error(context, "Unterminated string");
                return NULL;
            }
            else
            {
                set_parse_interrupted_at(context, read_pos);
                return string;
            }
        }

        if(*read_pos != '\\')
        {
            *write_pos++ = *read_pos;
            continue;
        }

        char* escape_pos = read_pos;
        read_pos++;

        switch(*read_pos)
        {
            case 0:
                if(is_last_data_segment(context))
                {
                    bo_notify_error(context, "Unterminated escape sequence");
                    return NULL;
                }
                else
                {
                    set_parse_interrupted_at(context, escape_pos);
                    return string;
                }
            case 'r': *write_pos++ = '\r'; break;
            case 'n': *write_pos++ = '\n'; break;
            case 't': *write_pos++ = '\t'; break;
            case '\\': *write_pos++ = '\\'; break;
            case '\"': *write_pos++ = '\"'; break;
            case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7':
            case '8': case '9': case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
            case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
            {
                if(!is_hex_character(read_pos[1]))
                {
                    if(is_last_data_segment(context) && read_pos[1] == 0)
                    {
                        set_parse_interrupted_at(context, escape_pos);
                        return string;
                    }
                    else
                    {
                        bo_notify_error(context, "Invalid hex sequence");
                        return NULL;
                    }
                }
                char number_buffer[3] = {read_pos[0], read_pos[1], 0};
                read_pos += 1;
                *write_pos++ = (uint8_t)strtoul(number_buffer, NULL, 16);
                break;
            }
            case 'u':
            {
                if(!is_hex_character(read_pos[1])
                || !is_hex_character(read_pos[2])
                || !is_hex_character(read_pos[3])
                || !is_hex_character(read_pos[4]))
                {
                    if(!is_last_data_segment(context) &&
                        ((read_pos[1] == 0) || (read_pos[2] == 0) || (read_pos[3] == 0) || (read_pos[4] == 0)))
                    {
                        set_parse_interrupted_at(context, escape_pos);
                        return string;
                    }
                    else
                    {
                        bo_notify_error(context, "Invalid unicode codepoint");
                        return NULL;
                    }
                }
                char number_buffer[5] = {read_pos[1], read_pos[2], read_pos[3], read_pos[4], 0};
                read_pos += 4;
                unsigned int codepoint = strtoul(number_buffer, NULL, 16);
                if(codepoint <= 0x7f)
                {
                    *write_pos++ = (char)codepoint;
                }
                else if(codepoint <= 0x7ff)
                {
                    *write_pos++ = (char)((codepoint >> 6) | 0xc0);
                    *write_pos++ = (char)((codepoint & 0x3f) | 0x80);
                }
                else
                {
                    *write_pos++ = (char)((codepoint >> 12) | 0xe0);
                    *write_pos++ = (char)(((codepoint >> 6) & 0x3f) | 0x80);
                    *write_pos++ = (char)((codepoint & 0x3f) | 0x80);
                }
                break;
            }
            default:
                bo_notify_error(context, "Invalid escape sequence");
                return NULL;
        }
    }
    *write_pos = 0;
    context->parse_position = read_pos;
    return string;
}



// ------
// Events
// ------

static void on_unknown_token(bo_context* context)
{
    char* token = context->parse_position;
    terminate_token(context);
    bo_notify_error(context, "%s: Unknown token", token);
}

static void on_string(bo_context* context)
{
    context->parse_position++;
    char* string = parse_string(context);
    if(!should_continue_parsing(context))
    {
        return;
    }

    bo_on_string(context, string);
}

static char* prefix_suffix_process_common(bo_context* context)
{
    char* token = context->parse_position;
    if(token[1] != '"')
    {
        terminate_token(context);
        bo_notify_error(context, "%s: Not a string", token + 1);
        return NULL;
    }

    context->parse_position += 2;
    char* string = parse_string(context);
    if(!should_continue_parsing(context))
    {
        context->parse_position = token;
    }
    return string;
}

static void on_prefix(bo_context* context)
{
    char* string = prefix_suffix_process_common(context);
    if(!should_continue_parsing(context))
    {
        return;
    }
    bo_on_prefix(context, string);
}

static void on_suffix(bo_context* context)
{
    char* string = prefix_suffix_process_common(context);
    if(!should_continue_parsing(context))
    {
        return;
    }
    bo_on_suffix(context, string);
}

static void on_input_type(bo_context* context)
{
    char* token = context->parse_position;
    terminate_token(context);
    int offset = 1;

    bo_data_type data_type = extract_data_type(context, token, offset);
    if(!should_continue_parsing(context))
    {
        context->parse_position = token;
        return;
    }
    offset += 1;

    int data_width = extract_data_width(context, token, offset);
    if(!should_continue_parsing(context))
    {
        context->parse_position = token;
        return;
    }
    offset += data_width > 8 ? 2 : 1;

    bo_endianness endianness = BO_ENDIAN_NONE;
    if(data_width > 1)
    {
        endianness = extract_endianness(context, token, offset);
        if(!should_continue_parsing(context))
        {
            context->parse_position = token;
            return;
        }
    }

    bo_on_input_type(context, data_type, data_width, endianness);
    if(!should_continue_parsing(context))
    {
        context->parse_position = token;
        return;
    }
}

static void on_output_type(bo_context* context)
{
    char* token = context->parse_position;
    terminate_token(context);
    int offset = 1;

    bo_data_type data_type = extract_data_type(context, token, offset);
    if(!should_continue_parsing(context))
    {
        context->parse_position = token;
        return;
    }
    offset += 1;

    int data_width = extract_data_width(context, token, offset);
    if(!should_continue_parsing(context))
    {
        context->parse_position = token;
        return;
    }
    offset += data_width > 8 ? 2 : 1;

    bo_endianness endianness = BO_ENDIAN_NONE;
    unsigned int print_width = 0;

    if(data_width > 1 || token[offset] != 0)
    {
        endianness = extract_endianness(context, token, offset);
        if(!should_continue_parsing(context))
        {
            context->parse_position = token;
            return;
        }
        offset += 1;

        if(data_type != TYPE_BINARY)
        {
            if(!is_decimal_character(token[offset]))
            {
                context->parse_position = token;
                char* reason = token[offset] == 0 ? "Missing print width" : "Not a valid print width";
                bo_notify_error(context, "%s: offset %d: %s", token, offset, reason);
                return;
            }

            print_width = strtoul(token + offset, NULL, 10);
        }
    }

    bo_on_output_type(context, data_type, data_width, endianness, print_width);
    if(!should_continue_parsing(context))
    {
        context->parse_position = token;
        return;
    }
}

static void on_preset(bo_context* context)
{
    char* token = context->parse_position;
    terminate_token(context);

    bo_on_preset(context, token + 1);
    if(!should_continue_parsing(context))
    {
        context->parse_position = token;
        return;
    }
}

static void on_number(bo_context* context)
{
    char* token = context->parse_position;
    terminate_token(context);

    bo_on_number(context, token);
    if(!should_continue_parsing(context))
    {
        context->parse_position = token;
        return;
    }
}



// ---------
// Parse API
// ---------

char* bo_process_data(void* void_context, char* data, int data_length, bool is_last_data_segment)
{
    bo_context* context = (bo_context*)void_context;
    context->parse_position = data;
    if(context->input.data_type == TYPE_BINARY)
    {
        bo_on_bytes(context, (uint8_t*)data, data_length);
        return context->parse_position;
    }

    // TODO
    data[data_length] = 0;
    bo_process(context, data, is_last_data_segment);
    return context->parse_position;
}

char* bo_process(void* void_context, char* string, bool is_last_data_segment)
{
    bo_context* context = (bo_context*)void_context;
    context->parse_position = string;
    context->is_last_data_segment = is_last_data_segment;
    context->is_at_end_of_input = false;
    context->is_error_condition = false;
    context->parse_should_continue = true;

    for(; !is_at_end_of_input(context) && should_continue_parsing(context) && *context->parse_position != 0;
        context->parse_position++)
    {
        switch(*context->parse_position)
        {
            case 0:
                break;
            case '\n':
                // TODO: Line count
                break;
            case ' ': case '\t': case '\r':
                break;
            case '"':
                on_string(context);
                break;
            case 'i':
                on_input_type(context);
                break;
            case 'o':
                on_output_type(context);
                break;
            case 'p':
                on_prefix(context);
                break;
            case 's':
                on_suffix(context);
                break;
            case 'P':
                on_preset(context);
                break;
            default:
                if(is_numeric_character(*context->parse_position))
                {
                    on_number(context);
                    break;
                }
                on_unknown_token(context);
                break;
        }
    }

    // TODO: Check for end of parse and pass any remaining data in directly.
    if(is_error_condition(context))
    {
        return NULL;
    }
    return context->parse_position;
}
